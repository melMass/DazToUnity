#include <dzapp.h>
#include <dzscene.h>
#include <dzexportmgr.h>
#include <dzexporter.h>
#include <dzmainwindow.h>
#include <dzmaterial.h>
#include <dzproperty.h>
#include <QtCore/qfile.h>
#include <QtCore/qtextstream.h>
#include <dzimageproperty.h>
#include <dzstringproperty.h>
#include <dznumericproperty.h>
#include <dzcolorproperty.h>
#include <dzstringproperty.h>
#include <dzenumproperty.h>
#include <dzboolproperty.h>
#include <dzobject.h>
#include <dzskeleton.h>
#include <dzfigure.h>
#include <dzshape.h>
#include <dzassetmgr.h>
#include <dzuri.h>
#include <dzcontentmgr.h>
#include <dzassetmetadata.h>
#include <dzbone.h>
#include <dzskeleton.h>
#include <dzpresentation.h>
#include <dzmodifier.h>
#include <dzmorph.h>

#include <QtCore/qdir.h>
#include <QtGui/qlineedit.h>
#include <QtNetwork/qudpsocket.h>
#include <QtNetwork/qabstractsocket.h>
#include <QtGui/qcheckbox.h>

#include "DzRuntimePluginAction.h"

DzRuntimePluginAction::DzRuntimePluginAction(const QString &text, const QString &desc) : DzAction(text, desc)
{
	ExportMorphs = false;
	ExportSubdivisions = false;
	ShowFbxDialog = false;
	ControllersToDisconnect.append("facs_bs_MouthClose_div2");
}

DzRuntimePluginAction::~DzRuntimePluginAction()
{
}

void DzRuntimePluginAction::Export()
{
	// FBX Export
	Selection = dzScene->getPrimarySelection();
	if (!Selection)
		return;

	QMap<QString, DzNode *> PropToInstance;
	if (AssetType == "Environment")
	{
		// Store off the original export information
		QString OriginalCharacterName = CharacterName;
		DzNode *OriginalSelection = Selection;

		// Find all the different types of props in the scene
		GetScenePropList(Selection, PropToInstance);
		QMap<QString, DzNode *>::iterator iter;
		for (iter = PropToInstance.begin(); iter != PropToInstance.end(); ++iter)
		{
			// Override the export info for exporting this prop
			AssetType = "StaticMesh";
			CharacterName = iter.key();
			CharacterName = CharacterName.remove(QRegExp("[^A-Za-z0-9_]"));
			CharacterFolder = ImportFolder + "\\" + CharacterName + "\\";
			CharacterFBX = CharacterFolder + CharacterName + ".fbx";
			DzNode *Node = iter.value();

			// If this is a figure, send it as a skeletal mesh
			if (DzSkeleton *Skeleton = Node->getSkeleton())
			{
				if (DzFigure *Figure = qobject_cast<DzFigure *>(Skeleton))
				{
					AssetType = "SkeletalMesh";
				}
			}

			// Disconnect the asset being sent from everything else
			QList<AttachmentInfo> AttachmentList;
			DisconnectNode(Node, AttachmentList);

			// Set the selection so this will be the exported asset
			Selection = Node;

			// Store the current transform and zero it out.
			DzVec3 Location;
			DzQuat Rotation;
			DzMatrix3 Scale;

			Node->getWSTransform(Location, Rotation, Scale);
			Node->setWSTransform(DzVec3(0.0f, 0.0f, 0.0f), DzQuat(), DzMatrix3(true));

			// Export
			ExportNode(Node);

			// Put the item back where it was
			Node->setWSTransform(Location, Rotation, Scale);

			// Reconnect all the nodes
			ReconnectNodes(AttachmentList);
		}

		// After the props have been exported, export the environment
		CharacterName = OriginalCharacterName;
		CharacterFolder = ImportFolder + "\\" + CharacterName + "\\";
		CharacterFBX = CharacterFolder + CharacterName + ".fbx";
		Selection = OriginalSelection;
		AssetType = "Environment";
		ExportNode(Selection);
	}
	else if (AssetType == "Pose")
	{
		PoseList.clear();
		DzNode *Selection = dzScene->getPrimarySelection();
		int poseIndex = 0;
		DzNumericProperty *previousProperty = nullptr;
		for (int index = 0; index < Selection->getNumProperties(); index++)
		{
			DzProperty *property = Selection->getProperty(index);
			DzNumericProperty *numericProperty = qobject_cast<DzNumericProperty *>(property);
			QString propName = property->getName();
			if (numericProperty)
			{
				QString propName = property->getName();
				if (MorphMapping.contains(propName))
				{
					poseIndex++;
					numericProperty->setDoubleValue(0.0f, 0.0f);
					for (int frame = 0; frame < MorphMapping.count() + 1; frame++)
					{
						numericProperty->setDoubleValue(dzScene->getTimeStep() * double(frame), 0.0f);
					}
					numericProperty->setDoubleValue(dzScene->getTimeStep() * double(poseIndex), 1.0f);
					PoseList.append(propName);
				}
			}
		}

		DzObject *Object = Selection->getObject();
		if (Object)
		{
			for (int index = 0; index < Object->getNumModifiers(); index++)
			{
				DzModifier *modifier = Object->getModifier(index);
				DzMorph *mod = qobject_cast<DzMorph *>(modifier);
				if (mod)
				{
					for (int propindex = 0; propindex < modifier->getNumProperties(); propindex++)
					{
						DzProperty *property = modifier->getProperty(propindex);
						QString propName = property->getName();
						QString propLabel = property->getLabel();
						DzNumericProperty *numericProperty = qobject_cast<DzNumericProperty *>(property);
						if (numericProperty)
						{
							QString propName = property->getName();
							qDebug() << propName;
							if (MorphMapping.contains(modifier->getName()))
							{
								poseIndex++;
								numericProperty->setDoubleValue(0.0f, 0.0f);
								for (int frame = 0; frame < MorphMapping.count() + 1; frame++)
								{
									numericProperty->setDoubleValue(dzScene->getTimeStep() * double(frame), 0.0f);
								}
								numericProperty->setDoubleValue(dzScene->getTimeStep() * double(poseIndex), 1.0f);
								PoseList.append(modifier->getName());
							}
						}
					}
				}
			}
		}

		dzScene->setAnimRange(DzTimeRange(0, poseIndex * dzScene->getTimeStep()));
		dzScene->setPlayRange(DzTimeRange(0, poseIndex * dzScene->getTimeStep()));

		ExportNode(Selection);
	}
	else if (AssetType == "SkeletalMesh")
	{
		QList<QString> DisconnectedModifiers = DisconnectOverrideControllers();
		DzNode *Selection = dzScene->getPrimarySelection();
		ExportNode(Selection);
		ReconnectOverrideControllers(DisconnectedModifiers);
	}
	else
	{
		DzNode *Selection = dzScene->getPrimarySelection();
		ExportNode(Selection);
	}
}

void DzRuntimePluginAction::DisconnectNode(DzNode *Node, QList<AttachmentInfo> &AttachmentList)
{
	AttachmentInfo ParentAttachment;
	if (Node->getNodeParent())
	{
		// Don't disconnect a figures bones
		if (DzBone *Bone = qobject_cast<DzBone *>(Node))
		{
		}
		else
		{
			ParentAttachment.Parent = Node->getNodeParent();
			ParentAttachment.Child = Node;
			AttachmentList.append(ParentAttachment);
			Node->getNodeParent()->removeNodeChild(Node);
		}
	}

	QList<DzNode *> ChildNodes;
	for (int ChildIndex = Node->getNumNodeChildren() - 1; ChildIndex >= 0; ChildIndex--)
	{
		DzNode *ChildNode = Node->getNodeChild(ChildIndex);
		if (DzBone *Bone = qobject_cast<DzBone *>(ChildNode))
		{
		}
		else
		{
			DzNode *ChildNode = Node->getNodeChild(ChildIndex);
			AttachmentInfo ChildAttachment;
			ChildAttachment.Parent = Node;
			ChildAttachment.Child = ChildNode;
			AttachmentList.append(ChildAttachment);
			Node->removeNodeChild(ChildNode);
		}
		DisconnectNode(ChildNode, AttachmentList);
	}
}

void DzRuntimePluginAction::ReconnectNodes(QList<AttachmentInfo> &AttachmentList)
{
	foreach (AttachmentInfo Attachment, AttachmentList)
	{
		Attachment.Parent->addNodeChild(Attachment.Child);
	}
}

void DzRuntimePluginAction::ExportNode(DzNode *Node)
{
	dzScene->selectAllNodes(false);
	dzScene->setPrimarySelection(Node);

	if (AssetType == "Environment")
	{
		QDir dir;
		dir.mkpath(CharacterFolder);
		WriteConfiguration();
		return;
	}

	DzExportMgr *ExportManager = dzApp->getExportMgr();
	DzExporter *Exporter = ExportManager->findExporterByClassName("DzFbxExporter");

	if (Exporter)
	{
		DzFileIOSettings ExportOptions;
		ExportOptions.setBoolValue("doSelected", true);
		ExportOptions.setBoolValue("doVisible", false);
		if (AssetType == "SkeletalMesh" || AssetType == "StaticMesh" || AssetType == "Environment")
		{
			ExportOptions.setBoolValue("doFigures", true);
			ExportOptions.setBoolValue("doProps", true);
		}
		else
		{
			ExportOptions.setBoolValue("doFigures", true);
			ExportOptions.setBoolValue("doProps", false);
		}
		ExportOptions.setBoolValue("doLights", false);
		ExportOptions.setBoolValue("doCameras", false);
		ExportOptions.setBoolValue("doAnims", true);
		if ((AssetType == "Animation" || AssetType == "SkeletalMesh") && ExportMorphs && MorphString != "")
		{
			ExportOptions.setBoolValue("doMorphs", true);
			ExportOptions.setStringValue("rules", MorphString);
		}
		else
		{
			ExportOptions.setBoolValue("doMorphs", false);
			ExportOptions.setStringValue("rules", "");
		}

		ExportOptions.setStringValue("format", FBXVersion);
		ExportOptions.setIntValue("RunSilent", !ShowFbxDialog);

		ExportOptions.setBoolValue("doEmbed", false);
		ExportOptions.setBoolValue("doCopyTextures", false);
		ExportOptions.setBoolValue("doDiffuseOpacity", false);
		ExportOptions.setBoolValue("doMergeClothing", true);
		ExportOptions.setBoolValue("doStaticClothing", false);
		ExportOptions.setBoolValue("degradedSkinning", true);
		ExportOptions.setBoolValue("degradedScaling", true);
		ExportOptions.setBoolValue("doSubD", false);
		ExportOptions.setBoolValue("doCollapseUVTiles", false);

		// get the top level node for things like clothing so we don't get dupe material names
		DzNode *Parent = Node;
		if (AssetType != "Environment")
		{
			while (Parent->getNodeParent() != NULL)
			{
				Parent = Parent->getNodeParent();
			}
		}

		// rename duplicate material names
		QList<QString> MaterialNames;
		QMap<DzMaterial *, QString> OriginalMaterialNames;
		RenameDuplicateMaterials(Parent, MaterialNames, OriginalMaterialNames);

		QDir dir;
		dir.mkpath(CharacterFolder);

		SetExportOptions(ExportOptions);
		Exporter->writeFile(CharacterFBX, &ExportOptions);

		WriteConfiguration();

		// Change back material names
		UndoRenameDuplicateMaterials(Parent, MaterialNames, OriginalMaterialNames);
	}
}

// If there are duplicate material names, save off the original and rename one
void DzRuntimePluginAction::RenameDuplicateMaterials(DzNode *Node, QList<QString> &MaterialNames, QMap<DzMaterial *, QString> &OriginalMaterialNames)
{
	DzObject *Object = Node->getObject();
	DzShape *Shape = Object ? Object->getCurrentShape() : NULL;

	if (Shape)
	{
		for (int i = 0; i < Shape->getNumMaterials(); i++)
		{
			DzMaterial *Material = Shape->getMaterial(i);
			if (Material)
			{
				OriginalMaterialNames.insert(Material, Material->getName());
				while (MaterialNames.contains(Material->getName()))
				{
					Material->setName(Material->getName() + "_1");
				}
				MaterialNames.append(Material->getName());
			}
		}
	}
	DzNodeListIterator Iterator = Node->nodeChildrenIterator();
	while (Iterator.hasNext())
	{
		DzNode *Child = Iterator.next();
		RenameDuplicateMaterials(Child, MaterialNames, OriginalMaterialNames);
	}
}

// Restore the original material names
void DzRuntimePluginAction::UndoRenameDuplicateMaterials(DzNode *Node, QList<QString> &MaterialNames, QMap<DzMaterial *, QString> &OriginalMaterialNames)
{
	QMap<DzMaterial *, QString>::iterator iter;
	for (iter = OriginalMaterialNames.begin(); iter != OriginalMaterialNames.end(); ++iter)
	{
		iter.key()->setName(iter.value());
	}
}

void DzRuntimePluginAction::GetScenePropList(DzNode *Node, QMap<QString, DzNode *> &Types)
{
	DzObject *Object = Node->getObject();
	DzShape *Shape = Object ? Object->getCurrentShape() : NULL;
	DzGeometry *Geometry = Shape ? Shape->getGeometry() : NULL;
	DzSkeleton *Skeleton = Node->getSkeleton();
	DzFigure *Figure = Skeleton ? qobject_cast<DzFigure *>(Skeleton) : NULL;
	//QString AssetId = Node->getAssetId();
	//IDzSceneAsset::AssetType Type = Node->getAssetType();

	// Use the FileName to generate a name for the prop to be exported
	QString Path = Node->getAssetFileInfo().getUri().getFilePath();
	QFile File(Path);
	QString FileName = File.fileName();
	QStringList Items = FileName.split("/");
	QStringList Parts = Items[Items.count() - 1].split(".");
	QString Name = Parts[0].remove(QRegExp("[^A-Za-z0-9_]"));

	if (Figure)
	{
		QString FigureAssetId = Figure->getAssetId();
		if (!Types.contains(Name))
		{
			Types.insert(Name, Node);
		}
	}
	else if (Geometry)
	{
		if (!Types.contains(Name))
		{
			Types.insert(Name, Node);
		}
	}

	// Looks through the child nodes for more props
	for (int ChildIndex = 0; ChildIndex < Node->getNumNodeChildren(); ChildIndex++)
	{
		DzNode *ChildNode = Node->getNodeChild(ChildIndex);
		GetScenePropList(ChildNode, Types);
	}
}

QList<QString> DzRuntimePluginAction::DisconnectOverrideControllers()
{
	QList<QString> ModifiedList;
	DzNode *Selection = dzScene->getPrimarySelection();
	int poseIndex = 0;
	DzNumericProperty *previousProperty = nullptr;
	for (int index = 0; index < Selection->getNumProperties(); index++)
	{
		DzProperty *property = Selection->getProperty(index);
		DzNumericProperty *numericProperty = qobject_cast<DzNumericProperty *>(property);
		QString propName = property->getName();
		if (numericProperty && !numericProperty->isOverridingControllers())
		{
			QString propName = property->getName();
			if (MorphMapping.contains(propName) && ControllersToDisconnect.contains(propName))
			{
				numericProperty->setOverrideControllers(true);
				ModifiedList.append(propName);
			}
		}
	}

	DzObject *Object = Selection->getObject();
	if (Object)
	{
		for (int index = 0; index < Object->getNumModifiers(); index++)
		{
			DzModifier *modifier = Object->getModifier(index);
			DzMorph *mod = qobject_cast<DzMorph *>(modifier);
			if (mod)
			{
				for (int propindex = 0; propindex < modifier->getNumProperties(); propindex++)
				{
					DzProperty *property = modifier->getProperty(propindex);
					QString propName = property->getName();
					QString propLabel = property->getLabel();
					DzNumericProperty *numericProperty = qobject_cast<DzNumericProperty *>(property);
					if (numericProperty && !numericProperty->isOverridingControllers())
					{
						QString propName = property->getName();
						if (MorphMapping.contains(modifier->getName()) && ControllersToDisconnect.contains(modifier->getName()))
						{
							numericProperty->setOverrideControllers(true);
							ModifiedList.append(modifier->getName());
						}
					}
				}
			}
		}
	}

	return ModifiedList;
}

void DzRuntimePluginAction::ReconnectOverrideControllers(QList<QString> &DisconnetedControllers)
{
	DzNode *Selection = dzScene->getPrimarySelection();
	int poseIndex = 0;
	DzNumericProperty *previousProperty = nullptr;
	for (int index = 0; index < Selection->getNumProperties(); index++)
	{
		DzProperty *property = Selection->getProperty(index);
		DzNumericProperty *numericProperty = qobject_cast<DzNumericProperty *>(property);
		QString propName = property->getName();
		if (numericProperty && numericProperty->isOverridingControllers())
		{
			QString propName = property->getName();
			if (DisconnetedControllers.contains(propName))
			{
				numericProperty->setOverrideControllers(false);
			}
		}
	}

	DzObject *Object = Selection->getObject();
	if (Object)
	{
		for (int index = 0; index < Object->getNumModifiers(); index++)
		{
			DzModifier *modifier = Object->getModifier(index);
			DzMorph *mod = qobject_cast<DzMorph *>(modifier);
			if (mod)
			{
				for (int propindex = 0; propindex < modifier->getNumProperties(); propindex++)
				{
					DzProperty *property = modifier->getProperty(propindex);
					QString propName = property->getName();
					QString propLabel = property->getLabel();
					DzNumericProperty *numericProperty = qobject_cast<DzNumericProperty *>(property);
					if (numericProperty && numericProperty->isOverridingControllers())
					{
						QString propName = property->getName();
						if (DisconnetedControllers.contains(modifier->getName()))
						{
							numericProperty->setOverrideControllers(false);
						}
					}
				}
			}
		}
	}
}

#include "moc_DzRuntimePluginAction.cpp"